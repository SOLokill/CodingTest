package algorithm_java;
/*
    problem :
    task :
    point :
        - 그래프를 사용한다. array로 선언해도 좋고, linkedList로 선언해도 좋다.
        - 여기서는 array를 사용해서 받는 값을 그대로 array index에 넣어 array 값만 true로 만들어준다. 무방향이기 때문에 반대 방향도 true로 바꿔야 한다.
        - 연결 요소는 어떤 특징을 가지고 있는지 생각한다.
        - 같은 간선은 한 번만 주어진다. <- 만약 같은 정점이나 간선이 또 들어오면 따로 처리를 해주어야 한다.
        - 방문하지 않았던 노드라도 간선이 있는지 확인 후에 dfs 돌리기
        - bfs는 간선이 있는지 확인하지 않아도 된다, 바로 인접 리스트에서 가지고 오기 때문에 연결되어 있다는 것을 보장한다.
    explain :
        - 인접 행렬을 쓰는 이유 : 왜냐하면 메모리 제한이 512mb인데 최대 1000까지 입력이 들어오니 행렬 선언을 해도 1000 * 1000 == 10 ^ 6 승이라 딱 1억 == 400~500mb 로 안전하게 들어간다.
        - DFS & BFS를 돌리면 시작점에서 시작해서 요소들을 방문한다.
        시작점부터 모든 정점들을 다 돌리기 시작하면 어떤 정점은 방문 배열에 들어가 있어 안돌아가는 정점이 있다.
        그러면 결국 DFS가 돌아간 정점만 세면 연결 요소의 개수를 구할 수 있다.
    conclusion :
 */
public class BK11724 {
}
